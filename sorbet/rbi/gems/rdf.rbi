# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rdf/all/rdf.rbi
#
# rdf-3.1.1
module RDF
  def self.Graph(**options, &block); end
  def self.List(*args); end
  def self.Literal(literal, **options); end
  def self.Node(*args); end
  def self.Resource(*args); end
  def self.Statement(*args, **options); end
  def self.StrictVocabulary(prefix); end
  def self.URI(*args); end
  def self.Vocabulary(uri); end
  def self.[](property); end
  def self.const_missing(constant); end
  def self.enum_for(method = nil, *args); end
  def self.method_missing(property, *args, &block); end
  def self.respond_to?(method, include_all = nil); end
  def self.to_enum(method = nil, *args); end
end
module RDF::VERSION
  def self.to_a; end
  def self.to_s; end
  def self.to_str; end
end
module RDF::Value
  def anonymous?; end
  def canonicalize!; end
  def canonicalize; end
  def constant?; end
  def graph?; end
  def inspect!; end
  def inspect; end
  def invalid?; end
  def iri?; end
  def list?; end
  def literal?; end
  def node?; end
  def resource?; end
  def start_with?(string); end
  def starts_with?(string); end
  def statement?; end
  def term?; end
  def to_rdf; end
  def to_term; end
  def type_error(message); end
  def uri?; end
  def valid?; end
  def validate!; end
  def validate; end
  def variable?; end
end
module RDF::Term
  def <=>(other); end
  def ==(other); end
  def compatible?(other); end
  def eql?(other); end
  def escape(string); end
  def term?; end
  def to_base; end
  def to_term; end
  include Comparable
  include RDF::Value
end
module RDF::Resource
  def resource?; end
  def self.new(*args, &block); end
  include RDF::Term
end
class RDF::URI
  def +(other); end
  def /(fragment); end
  def ==(other); end
  def ===(other); end
  def =~(pattern); end
  def _dump(level); end
  def absolute?; end
  def authority; end
  def authority=(value); end
  def canonicalize!; end
  def canonicalize; end
  def dup; end
  def end_with?(string); end
  def ends_with?(string); end
  def eql?(other); end
  def format_authority; end
  def format_userinfo(append = nil); end
  def fragment; end
  def fragment=(value); end
  def freeze; end
  def has_parent?; end
  def hash; end
  def hier?; end
  def host; end
  def host=(value); end
  def initialize(*args, validate: nil, canonicalize: nil, **options); end
  def inspect; end
  def join(*uris); end
  def length; end
  def normalize!; end
  def normalize; end
  def normalize_segment(value, expr, downcase = nil); end
  def normalized_authority; end
  def normalized_fragment; end
  def normalized_host; end
  def normalized_password; end
  def normalized_path; end
  def normalized_port; end
  def normalized_query; end
  def normalized_scheme; end
  def normalized_user; end
  def normalized_userinfo; end
  def object; end
  def parent; end
  def parse(value); end
  def password; end
  def password=(value); end
  def path; end
  def path=(value); end
  def pname; end
  def port; end
  def port=(value); end
  def qname; end
  def query; end
  def query=(value); end
  def query_values(return_type = nil); end
  def query_values=(value); end
  def relative?; end
  def relativize(base_uri); end
  def request_uri; end
  def root; end
  def root?; end
  def scheme; end
  def scheme=(value); end
  def self._load(data); end
  def self.cache; end
  def self.decode(str); end
  def self.encode(str, expr); end
  def self.intern(str, *args, **options); end
  def self.normalize_path(path); end
  def self.parse(str); end
  def size; end
  def to_h; end
  def to_s; end
  def to_str; end
  def to_uri; end
  def uri?; end
  def url?; end
  def urn?; end
  def user; end
  def user=(value); end
  def userinfo; end
  def userinfo=(value); end
  def valid?; end
  def validate!; end
  def value; end
  include RDF::Resource
end
class RDF::Node
  def ==(other); end
  def ===(other); end
  def anonymous?; end
  def dup; end
  def eql?(other); end
  def hash; end
  def id; end
  def id=(arg0); end
  def initialize(id = nil); end
  def labeled?; end
  def make_unique!; end
  def node?; end
  def original; end
  def original=(arg0); end
  def self.cache; end
  def self.intern(id); end
  def self.uuid(format: nil); end
  def to_s; end
  def to_sym; end
  def to_unique_base; end
  def unlabeled?; end
  include RDF::Resource
end
class RDF::Literal
  def ==(other); end
  def ===(other); end
  def canonicalize!; end
  def compatible?(other); end
  def comperable_datatype?(other); end
  def datatype; end
  def datatype=(arg0); end
  def datatype?; end
  def datatyped?; end
  def eql?(other); end
  def escape(string); end
  def freeze; end
  def has_datatype?; end
  def has_language?; end
  def hash; end
  def humanize(lang = nil); end
  def initialize(value, language: nil, datatype: nil, lexical: nil, validate: nil, canonicalize: nil, **options); end
  def inspect; end
  def language; end
  def language=(arg0); end
  def language?; end
  def literal?; end
  def method_missing(name, *args); end
  def object; end
  def plain?; end
  def respond_to_missing?(name, include_private = nil); end
  def self.datatype_map; end
  def self.datatyped_class(uri); end
  def self.inherited(child); end
  def self.new(value, language: nil, datatype: nil, lexical: nil, validate: nil, canonicalize: nil, **options); end
  def simple?; end
  def squish!; end
  def squish(*other_string); end
  def to_s; end
  def typed?; end
  def valid?; end
  def validate!; end
  def value; end
  def value_hash; end
  include RDF::Term
end
class RDF::Literal::Numeric < RDF::Literal
  def *(other); end
  def +(other); end
  def +@; end
  def -(other); end
  def -@; end
  def /(other); end
  def <=>(other); end
  def ==(other); end
  def abs; end
  def ceil; end
  def floor; end
  def ord; end
  def round; end
  def to_d; end
  def to_f; end
  def to_i; end
  def to_int; end
  def to_r; end
end
class RDF::Literal::Boolean < RDF::Literal
  def <=>(other); end
  def ==(other); end
  def canonicalize!; end
  def false?; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def inspect; end
  def to_i; end
  def to_s; end
  def true?; end
end
class RDF::Literal::Decimal < RDF::Literal::Numeric
  def abs; end
  def canonicalize!; end
  def ceil; end
  def floor; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def nonzero?; end
  def round; end
  def to_s; end
  def zero?; end
end
class RDF::Literal::Integer < RDF::Literal::Decimal
  def abs; end
  def canonicalize!; end
  def even?; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def next; end
  def nonzero?; end
  def odd?; end
  def pred; end
  def round; end
  def succ; end
  def to_bn; end
  def to_s; end
  def zero?; end
end
class RDF::Literal::Double < RDF::Literal::Numeric
  def <=>(other); end
  def ==(other); end
  def abs; end
  def canonicalize!; end
  def ceil; end
  def finite?; end
  def floor; end
  def infinite?; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def nan?; end
  def nonzero?; end
  def round; end
  def to_s; end
  def zero?; end
end
class RDF::Literal::Date < RDF::Literal
  def ==(other); end
  def canonicalize!; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = nil); end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def to_s; end
  def tz; end
  def valid?; end
end
class RDF::Literal::DateTime < RDF::Literal
  def ==(other); end
  def canonicalize!; end
  def has_milliseconds?; end
  def has_ms?; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = nil); end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def timezone; end
  def to_s; end
  def tz; end
  def valid?; end
end
class RDF::Literal::Time < RDF::Literal
  def ==(other); end
  def canonicalize!; end
  def has_timezone?; end
  def has_tz?; end
  def humanize(lang = nil); end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def to_s; end
  def tz; end
  def valid?; end
end
class RDF::Literal::Token < RDF::Literal
  def canonicalize!; end
  def initialize(value, datatype: nil, lexical: nil, **options); end
  def to_s; end
  def to_sym; end
end
module RDF::Util
end
module RDF::Util::Aliasing
end
module RDF::Util::Aliasing::LateBound
  def alias_method(new_name, old_name); end
end
module RDF::Countable
  def count; end
  def empty?; end
  def enum_for(method = nil, *args); end
  def size(*args, &block); end
  def to_enum(*args, &block); end
  extend RDF::Util::Aliasing::LateBound
end
module RDF::Enumerable
  def dump(*args, **options); end
  def each_graph; end
  def each_object; end
  def each_predicate; end
  def each_quad; end
  def each_statement(&block); end
  def each_subject; end
  def each_term; end
  def each_triple; end
  def enum_for(method = nil, *args); end
  def enum_graph; end
  def enum_graphs(*args, &block); end
  def enum_object; end
  def enum_objects(*args, &block); end
  def enum_predicate; end
  def enum_predicates(*args, &block); end
  def enum_quad; end
  def enum_quads(*args, &block); end
  def enum_statement; end
  def enum_statements(*args, &block); end
  def enum_subject; end
  def enum_subjects(*args, &block); end
  def enum_term; end
  def enum_terms(*args, &block); end
  def enum_triple; end
  def enum_triples(*args, &block); end
  def graph_names(unique: nil); end
  def has_graph?(graph_name); end
  def has_object?(value); end
  def has_predicate?(value); end
  def has_quad?(quad); end
  def has_statement?(statement); end
  def has_subject?(value); end
  def has_term?(value); end
  def has_triple?(triple); end
  def include?(*args, &block); end
  def invalid?; end
  def method_missing(meth, *args); end
  def objects(unique: nil); end
  def predicates(unique: nil); end
  def project_graph(graph_name); end
  def quads(**options); end
  def respond_to_missing?(name, include_private = nil); end
  def statements(**options); end
  def subjects(unique: nil); end
  def supports?(feature); end
  def terms(unique: nil); end
  def to_a; end
  def to_enum(*args, &block); end
  def to_h; end
  def to_set; end
  def triples(**options); end
  def valid?; end
  def validate!; end
  def validate(*args, &block); end
  extend RDF::Util::Aliasing::LateBound
  include Enumerable
  include RDF::Countable
end
class RDF::Query
  def +(other); end
  def <<(pattern); end
  def apply_graph_name(graph_name = nil); end
  def compile_hash_patterns(hash_patterns); end
  def default?; end
  def dup; end
  def each(&block); end
  def each_solution(&block); end
  def each_statement(&block); end
  def empty?; end
  def execute(queryable, bindings: nil, solutions: nil, graph_name: nil, name: nil, **options, &block); end
  def failed?; end
  def graph_name; end
  def graph_name=(arg0); end
  def has_blank_nodes?; end
  def has_variables?; end
  def initialize(*patterns, solutions: nil, graph_name: nil, name: nil, validate: nil, **options, &block); end
  def matched?; end
  def named?; end
  def node?; end
  def optimize!(**options); end
  def optimize(**options); end
  def options; end
  def pattern(pattern, **options); end
  def patterns; end
  def self.Solutions(*args); end
  def self.execute(queryable, patterns = nil, options = nil, &block); end
  def solutions; end
  def unnamed?; end
  def valid?; end
  def validate!; end
  def variable?; end
  def variable_count; end
  def variables; end
  def variables?; end
  include RDF::Enumerable
end
class RDF::Statement
  def ==(other); end
  def ===(other); end
  def [](index); end
  def []=(index, value); end
  def asserted?; end
  def canonicalize!; end
  def canonicalize; end
  def complete?; end
  def eql?(other); end
  def graph_name; end
  def graph_name=(arg0); end
  def has_blank_nodes?; end
  def has_graph?; end
  def has_name?; end
  def has_object?; end
  def has_predicate?; end
  def has_subject?; end
  def hash; end
  def id; end
  def id=(arg0); end
  def incomplete?; end
  def inferred?; end
  def initialize!; end
  def initialize(subject = nil, predicate = nil, object = nil, options = nil); end
  def invalid?; end
  def node?; end
  def object; end
  def object=(arg0); end
  def options; end
  def options=(arg0); end
  def predicate; end
  def predicate=(arg0); end
  def quoted?; end
  def reified(subject: nil, id: nil, graph_name: nil); end
  def self.from(statement, graph_name: nil, **options); end
  def statement?; end
  def subject; end
  def subject=(arg0); end
  def to_a; end
  def to_h(subject_key = nil, predicate_key = nil, object_key = nil, graph_key = nil); end
  def to_quad; end
  def to_s; end
  def to_triple; end
  def valid?; end
  def variable?; end
  include RDF::Value
end
class RDF::Query::Pattern < RDF::Statement
  def arity; end
  def bind(solution); end
  def binding_count; end
  def bindings; end
  def bindings?; end
  def blank?; end
  def bound?; end
  def bound_variables; end
  def cardinality; end
  def cost; end
  def cost=(arg0); end
  def execute(queryable, bindings = nil, &block); end
  def has_variables?; end
  def initialize!; end
  def initialize(subject = nil, predicate = nil, object = nil, options = nil); end
  def optional?; end
  def options; end
  def self.from(pattern, graph_name: nil, **options); end
  def solution(statement); end
  def to_s; end
  def unbound?; end
  def unbound_variables; end
  def valid?; end
  def variable_count; end
  def variable_terms(name = nil); end
  def variables; end
  def variables?; end
end
class RDF::Query::Variable
  def ==(other); end
  def ===(other); end
  def bind!(value); end
  def bind(value); end
  def bindings; end
  def bound?; end
  def distinguished=(value); end
  def distinguished?; end
  def eql?(other); end
  def existential=(value); end
  def existential?; end
  def hash; end
  def initialize(name = nil, value = nil, distinguished: nil, existential: nil); end
  def name; end
  def name=(arg0); end
  def named?; end
  def to_h; end
  def to_s; end
  def to_sym; end
  def unbind!; end
  def unbind; end
  def unbound?; end
  def value; end
  def value=(arg0); end
  def variable?; end
  def variables; end
  include RDF::Term
end
